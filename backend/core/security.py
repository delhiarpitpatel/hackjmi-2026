"""
Security utilities:
- Password hashing (bcrypt)
- JWT access & refresh tokens
- Biometric token verification (Face ID / Fingerprint stub)
- Aadhaar FaceRD integration stub
- Current user dependency
"""
from datetime import datetime, timedelta, timezone
from typing import Optional, Annotated
import httpx
import bcrypt

from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt

from core.config import settings
from core.database import get_db
from sqlalchemy.ext.asyncio import AsyncSession

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login")


# -- Passwords -----------------------------------------------------------------

def _to_bytes(plain: str) -> bytes:
    """Encode and truncate to 72 bytes â€” bcrypt's hard limit."""
    return plain.encode("utf-8")[:72]


def hash_password(plain: str) -> str:
    return bcrypt.hashpw(_to_bytes(plain), bcrypt.gensalt()).decode("utf-8")


def verify_password(plain: str, hashed: str) -> bool:
    return bcrypt.checkpw(_to_bytes(plain), hashed.encode("utf-8"))


# -- JWT Tokens ----------------------------------------------------------------

def create_access_token(subject: str, extra: dict = {}) -> str:
    expire = datetime.now(timezone.utc) + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    payload = {"sub": subject, "exp": expire, "type": "access", **extra}
    return jwt.encode(payload, settings.SECRET_KEY, algorithm=settings.ALGORITHM)


def create_refresh_token(subject: str) -> str:
    expire = datetime.now(timezone.utc) + timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
    payload = {"sub": subject, "exp": expire, "type": "refresh"}
    return jwt.encode(payload, settings.SECRET_KEY, algorithm=settings.ALGORITHM)


def decode_token(token: str) -> dict:
    try:
        return jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired token",
            headers={"WWW-Authenticate": "Bearer"},
        )


# -- Biometric Auth (Phase 2) --------------------------------------------------

async def verify_biometric_token(biometric_token: str, user_id: str) -> bool:
    """
    Verify a biometric token generated by the device's native biometric stack
    (Face ID / Fingerprint via NPCI on-device SDK).

    In production: validate the signed JWT/assertion from the device SDK.
    Here we validate the token structure as a placeholder.
    """
    try:
        payload = decode_token(biometric_token)
        return payload.get("sub") == user_id and payload.get("type") == "biometric"
    except Exception:
        return False


async def verify_aadhaar_face(aadhaar_number: str, face_image_b64: str) -> dict:
    """
    Call UIDAI FaceRD API for Aadhaar-based facial recognition.
    Used for initial setup or PIN resets (Phase 2).

    Returns: {"verified": bool, "confidence": float}
    """
    PLACEHOLDER = "your_uidai_key"
    api_key = (settings.UIDAI_API_KEY or "").strip()

    # Return stub if no real key is configured
    if not api_key or api_key == PLACEHOLDER:
        return {"verified": True, "confidence": 0.97, "stub": True}

    async with httpx.AsyncClient() as client:
        resp = await client.post(
            settings.UIDAI_API_URL,
            json={"aadhaar_number": aadhaar_number, "face_image": face_image_b64},
            headers={"x-api-key": api_key},
            timeout=10.0,
        )
        resp.raise_for_status()
        return resp.json()


# -- Current User Dependency ---------------------------------------------------

async def get_current_user(
    token: Annotated[str, Depends(oauth2_scheme)],
    db: AsyncSession = Depends(get_db),
):
    from models.user import User
    from sqlalchemy import select

    payload = decode_token(token)
    user_id: str = payload.get("sub")
    if not user_id:
        raise HTTPException(status_code=401, detail="Invalid token subject")

    result = await db.execute(select(User).where(User.id == user_id))
    user = result.scalar_one_or_none()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    if not user.is_active:
        raise HTTPException(status_code=403, detail="Inactive user account")
    return user


async def get_current_active_user(
    current_user=Depends(get_current_user),
):
    return current_user
